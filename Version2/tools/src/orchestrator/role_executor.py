#!/usr/bin/env python3
"""Deterministic role execution for Version2 orchestrator.

Simulation mode: generates required artifacts deterministically.
Realization mode: delegates step execution to the active idea workspace adapter.
"""

from __future__ import annotations

import json
import subprocess
import sys
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict, List, Optional


ROOT = Path(__file__).resolve().parents[3]
WORKFLOWS_DIR = ROOT / ".windseruf" / "workflows"


def _utc_now() -> str:
    return datetime.now(timezone.utc).replace(microsecond=0).isoformat().replace("+00:00", "Z")


def _charter_mission(role: str) -> str:
    charter = WORKFLOWS_DIR / f"{role}.md"
    if not charter.exists():
        return "Mission not found in role charter."
    text = charter.read_text(encoding="utf-8")
    for line in text.splitlines():
        if line.strip().startswith("mission:"):
            return line.split(":", 1)[1].strip()
    return "Mission not found in role charter."


def _render_markdown_artifact(
    output_name: str,
    role: str,
    phase: str,
    step_id: str,
    profile_name: str,
    status: Dict[str, Any],
) -> str:
    mission = _charter_mission(role)
    now = _utc_now()
    mode_note = "realization" if str(status.get("execution_mode", "simulation")) == "realization" else "simulation"
    summary = (
        "This artifact summarizes role output produced by the idea workspace adapter."
        if mode_note == "realization"
        else "This artifact was generated by deterministic orchestrator role execution."
    )
    return (
        f"# {output_name}\n\n"
        f"- Profile: `{profile_name}`\n"
        f"- Phase: `{phase}`\n"
        f"- Role: `{role}`\n"
        f"- Step: `{step_id}`\n"
        f"- Mode: `{mode_note}`\n"
        f"- Generated At: `{now}`\n\n"
        f"## Mission Alignment\n"
        f"{mission}\n\n"
        "## Execution Summary\n"
        f"{summary}\n"
        "It satisfies required output contract for the active profile step.\n"
    )


def _render_scoreboard(status: Dict[str, Any], profile_name: str) -> str:
    now = _utc_now()
    roles = sorted(
        {
            str(step.get("role", "unknown"))
            for step in status.get("phase_plan", [])
            if isinstance(step, dict)
        }
    )
    payload = {
        "profile": profile_name,
        "score_run_id": status.get("score_run_id", ""),
        "generated_at": now,
        "rubric_version": "v2.1",
        "roles": [
            {
                "role": role,
                "score": 8,
                "notes": "Deterministic baseline score from charter execution compliance.",
            }
            for role in roles
        ],
    }
    return json.dumps(payload, indent=2) + "\n"


def _git(workspace: Path, *args: str) -> subprocess.CompletedProcess:
    return subprocess.run(
        ["git", *args],
        cwd=workspace,
        capture_output=True,
        text=True,
        check=False,
    )


def _append_workspace_file(path: Path, line: str) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("a", encoding="utf-8") as f:
        f.write(line)


def _commit_type_for(role: str, step_type: str) -> str:
    if step_type == "reviewer":
        return "review"
    if role in {"qa_engineer", "integration_tester"}:
        return "test"
    if role == "security_engineer":
        return "security"
    if role == "technical_writer":
        return "docs"
    if role in {"release_manager", "devops_engineer"}:
        return "chore"
    return "feat"


def _commit_workspace_step(workspace: Path, role: str, step_id: str, step_type: str) -> Dict[str, str]:
    status = _git(workspace, "status", "--porcelain")
    if status.returncode != 0:
        raise RuntimeError(f"git status failed: {(status.stderr or status.stdout).strip()}")
    if not status.stdout.strip():
        stamp = workspace / ".orchestrator" / f"{step_id}.txt"
        stamp.parent.mkdir(parents=True, exist_ok=True)
        _append_workspace_file(stamp, f"{_utc_now()} {role} {step_id}\n")

    add = _git(workspace, "add", "-A")
    if add.returncode != 0:
        raise RuntimeError(f"git add failed: {(add.stderr or add.stdout).strip()}")

    msg = f"{_commit_type_for(role, step_type)}({role}): {step_id} updates"
    commit = _git(workspace, "commit", "-m", msg)
    if commit.returncode != 0:
        raise RuntimeError(f"git commit failed: {(commit.stderr or commit.stdout).strip()}")

    sha = _git(workspace, "rev-parse", "HEAD")
    if sha.returncode != 0:
        raise RuntimeError(f"git rev-parse failed: {(sha.stderr or sha.stdout).strip()}")
    return {"commit_sha": (sha.stdout or "").strip(), "message": msg}


def _parse_adapter_payload(stdout: str) -> Dict[str, Any]:
    text = (stdout or "").strip()
    if not text:
        return {}

    # Prefer JSON from last non-empty line to allow adapter logs above payload.
    for line in reversed(text.splitlines()):
        line = line.strip()
        if not line:
            continue
        try:
            payload = json.loads(line)
        except json.JSONDecodeError:
            continue
        if isinstance(payload, dict):
            return payload
    return {}


def _invoke_workspace_adapter(
    workspace: Path,
    step: Dict[str, Any],
    profile_name: str,
    artifacts_dir: Path,
) -> Dict[str, Any]:
    adapter = workspace / "adapter" / "role_adapter.py"
    if not adapter.exists():
        raise RuntimeError(
            f"Realization adapter is missing: {adapter}. "
            "Expected an idea-local adapter under implementations/<idea_id>/adapter/."
        )

    role = str(step.get("role", "unknown"))
    phase = str(step.get("phase", "unknown"))
    step_id = str(step.get("step_id", "step"))
    step_type = str(step.get("step_type", "owner"))
    artifacts_path = artifacts_dir.resolve()

    cmd = [
        sys.executable,
        str(adapter),
        "run-step",
        "--role",
        role,
        "--phase",
        phase,
        "--step-id",
        step_id,
        "--step-type",
        step_type,
        "--profile",
        profile_name,
        "--artifacts-dir",
        str(artifacts_path),
    ]

    run = subprocess.run(cmd, capture_output=True, text=True, cwd=workspace, check=False)
    if run.returncode != 0:
        detail = (run.stderr or "").strip() or (run.stdout or "").strip() or "adapter failed"
        raise RuntimeError(f"Role adapter execution failed for `{role}`: {detail}")

    return _parse_adapter_payload(run.stdout)


def execute_step(
    status: Dict[str, Any],
    step: Dict[str, Any],
    profile_name: str,
    artifacts_dir: Optional[Path] = None,
    workspace_dir: Optional[Path] = None,
    execution_mode: str = "simulation",
) -> List[str]:
    """
    Generate required artifacts for the active step and mark role work complete.

    Returns:
        list of generated output names.
    """
    role = str(step.get("role", "unknown"))
    phase = str(step.get("phase", "unknown"))
    step_id = str(step.get("step_id", "unknown_step"))
    step_type = str(step.get("step_type", "owner"))
    required_outputs = [str(item) for item in step.get("required_outputs", [])]

    if artifacts_dir is None:
        artifacts_dir = ROOT / "agent_runtime" / "artifacts"
    artifacts_dir = artifacts_dir.resolve()
    artifacts_dir.mkdir(parents=True, exist_ok=True)

    artifacts = status.setdefault("artifacts", {})
    handoff_packet = status.setdefault("handoff_packet", {})
    now = _utc_now()

    adapter_payload: Dict[str, Any] = {}
    if execution_mode == "realization":
        if workspace_dir is None:
            raise RuntimeError("workspace_dir is required for realization execution mode.")

        adapter_payload = _invoke_workspace_adapter(
            workspace=workspace_dir,
            step=step,
            profile_name=profile_name,
            artifacts_dir=artifacts_dir,
        )

        commit_meta = _commit_workspace_step(
            workspace=workspace_dir,
            role=role,
            step_id=step_id,
            step_type=step_type,
        )
        status.setdefault("commit_evidence", []).append(
            {
                "step_id": step_id,
                "role": role,
                "commit_sha": commit_meta["commit_sha"],
                "message": commit_meta["message"],
                "created_at": now,
            }
        )
        status.setdefault("role_attempts", {})
        status["role_attempts"][role] = int(status["role_attempts"].get(role, 0)) + 1

        for key in ["review_status", "integration_loop_status", "integration_failure_target", "last_failed_role"]:
            if key in adapter_payload:
                status[key] = adapter_payload[key]

    generated: List[str] = []
    for output_name in required_outputs:
        artifact_path = artifacts_dir / output_name
        artifact_path.parent.mkdir(parents=True, exist_ok=True)

        if output_name.endswith(".json") and output_name == "role_scoreboard.json":
            artifact_path.write_text(_render_scoreboard(status, profile_name), encoding="utf-8")
        else:
            artifact_path.write_text(
                _render_markdown_artifact(
                    output_name=output_name,
                    role=role,
                    phase=phase,
                    step_id=step_id,
                    profile_name=profile_name,
                    status=status,
                ),
                encoding="utf-8",
            )

        artifacts[output_name] = {
            "path": str(artifact_path),
            "owner": role,
            "updated_at": now,
        }
        generated.append(output_name)

    handoff_packet["provided_outputs"] = list(generated)
    handoff_packet["missing_outputs"] = []
    handoff_packet["updated_at"] = now
    status["role_status"] = "completed"

    if step_type == "reviewer" and "review_status" not in adapter_payload:
        status["review_status"] = "approved"

    return generated
